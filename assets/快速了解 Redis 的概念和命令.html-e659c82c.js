import{_ as l,W as a,X as r,Y as e,Z as d,a0 as c,a2 as i,C as t}from"./framework-a9f5de78.js";const s={},n=i('<h2 id="番外篇" tabindex="-1"><a class="header-anchor" href="#番外篇" aria-hidden="true">#</a> 番外篇</h2><p>继上次送书之后，好多小伙伴纷纷表示名额太少了，根本没有参与的欲望，只能默默地看着别人把书拿走。所以今天阿Q为大家准备了<strong>更多</strong>的名额，文末参与把书带回家。</p><h2 id="概念篇" tabindex="-1"><a class="header-anchor" href="#概念篇" aria-hidden="true">#</a> 概念篇</h2><p>一提到<code>Redis</code>，大家听到最多的应该就是“主从”、“集群”、“哨兵”了吧。对于不太精通的同学来说，乍一听这些概念，有的人会心向往之，有的人会望而却步。今天我们先来扒一扒<code>Redis</code>的“底裤”。</p><h3 id="什么是-redis" tabindex="-1"><a class="header-anchor" href="#什么是-redis" aria-hidden="true">#</a> 什么是 Redis?</h3><p><code>Redis</code>是<code>REmote DIctionary Server</code>的简称，意为“远程字典服务器”。它是基于<code>BSD</code>协议的完全开源的高性能的<code>key-value</code>数据库。</p><p>它是一个单线程却性能极好的内存数据库，所有的操作都是按照顺序线性执行的，避免了不必要的上下文切换和竞争条件。</p><p>采用非阻塞<code>I/O</code>的形式进行通信，利用<code>Epoll</code>的多路复用特性，提高了<code>I/O</code>效率。</p><p>给大家提供两个官方网址：</p>',9),h={href:"http://www.redis.cn/",target:"_blank",rel:"noopener noreferrer"},k={href:"http://www.redis.io/",target:"_blank",rel:"noopener noreferrer"},y=i('<blockquote><p>默认16个库:0-15，默认使用0库；统一密码，默认端口6379（九宫格的<code>merz</code>）</p></blockquote><h3 id="redis的特点" tabindex="-1"><a class="header-anchor" href="#redis的特点" aria-hidden="true">#</a> Redis的特点</h3><ul><li><strong>内存存储和持久化</strong>：支持异步将内存中的数据写到硬盘上，同时不影响“取最新N个数据”的服务操作，重启的时候可以再次加载进内存</li><li><strong>发布、订阅消息系统</strong></li><li><strong>定时器、计数器</strong>：可设定过期时间</li><li><strong>数据结构多样</strong>：支持<code>String</code>、<code>list</code>，<code>set</code>，<code>zset</code>，<code>hash</code>等多种数据结构的存储</li><li><strong>数据备份</strong>：即<code>master-slave</code>模式的数据备份</li><li><strong>高性能</strong>：读的速度是<code>110000</code>次/s，写的速度是<code>81000</code>次/s</li><li><strong>原子性</strong>：所有操作都是原子性的：单个操作是原子性的；多个操作也支持事务，通过<code>MULTI</code>和<code>EXEC</code>指令包起来</li></ul>',3),u={href:"https://mp.weixin.qq.com/s/Br7SVJK88Cd-3rKmAabGDw",target:"_blank",rel:"noopener noreferrer"},m=i('<h2 id="命令篇" tabindex="-1"><a class="header-anchor" href="#命令篇" aria-hidden="true">#</a> 命令篇</h2><h3 id="key命令" tabindex="-1"><a class="header-anchor" href="#key命令" aria-hidden="true">#</a> key命令</h3><ul><li><code>select db</code>：<code>db</code>为数字，表示切换数据库为<code>db</code>库</li><li><code>Dbsize</code>：查看当前数据库的<code>key</code>的数量</li><li><code>Flushdb</code>：清空当前库的所有<code>key</code></li><li><code>Flushall</code>：清空所有库的<code>key</code>（几乎不用）</li><li><code>keys *</code> ：所有<code>key</code>罗列</li><li><code>exists key</code>：判断<code>key</code>是否存在</li><li><code>move key db</code>：将<code>key</code>移动到<code>db</code>库（当前库的<code>key</code>没有了），如果当前库不存在<code>key</code>，则失败；如果当前库与<code>db</code>库都存在<code>key</code>值，则不移动</li><li><code>expire key seconds</code>：为<code>key</code>设置过期时间</li><li><code>ttl key</code>：查看还有多少秒过期，-1表示永不过期，-2表示已过期</li><li><code>type key</code>：查看你的<code>key</code>是什么类型</li><li><code>del key</code>：删除<code>key</code></li></ul><blockquote><p>执行命令：1生效，0不生效</p></blockquote><h3 id="string-字符串" tabindex="-1"><a class="header-anchor" href="#string-字符串" aria-hidden="true">#</a> String（字符串）</h3><p>一个<code>key</code>对应一个<code>value</code>，一个键最大能存储<code>512MB</code>，是二进制安全的。</p><h4 id="命令" tabindex="-1"><a class="header-anchor" href="#命令" aria-hidden="true">#</a> 命令</h4><ul><li><code>SET key value</code>：设置<code>key</code>的值</li><li><code>GET key</code>：获取<code>key</code>的值</li><li><code>del key</code>：删除<code>key</code></li><li><code>append key value</code>：如果<code>key</code>已经存在并且是一个字符串，<code>APPEND</code>命令将指定的<code>value</code>追加到该<code>key</code>原来值（<code>value</code>）的末尾</li><li><code>strlen key</code>：返回<code>key</code>所储存的字符串值的长度</li><li><code>getrange key start end</code>：返回<code>key</code>中字符串值的子字符；（0，-1）返回全部</li><li><code>setrange key offset value</code>：用<code>value</code>参数覆写给定<code>key</code>所储存的字符串值，从偏移量<code>offset</code>开始</li><li><code>setex key seconds value</code>：(set with expire)给<code>key</code>设置<code>value</code>，并在<code>seconds</code>秒后过期</li><li><code>setnx key value</code>：(set if not exist)先判断<code>key</code>的<code>value</code>是否存在，不存在再插入，防止覆盖</li><li><code>mset key value [key value ...]</code>：同时设置一个或多个<code>key-value</code>对</li><li><code>mget key1 [key2...]</code>：同时获取一个或者多个<code>key</code>的<code>value</code>值</li><li><code>msetnx key value [key value ...]</code>：同时设置一个或多个<code>key-value</code>对，当且仅当所有给定<code>key</code>都不存在（有存在，有不存在的都不存）</li><li><code>getset key value</code>：将给定<code>key</code>的值设为<code>value</code>，并返回<code>key</code>的旧值(<code>old value</code>)。</li></ul><p><strong>一定要是数字才能进行加减</strong></p><ul><li><code>incr key</code>：将<code>key</code>中存储的数字加一</li><li><code>decr key</code>：将<code>key</code>中储存的数字值减一</li><li><code>incrby key increment</code>：将<code>key</code>所储存的值加上给定的增量值（<code>increment</code>）</li><li><code>decrby key decrement</code>：将<code>key</code>所储存的值减去给定的减量值（<code>decrement</code>）</li></ul><h3 id="hash-哈希" tabindex="-1"><a class="header-anchor" href="#hash-哈希" aria-hidden="true">#</a> Hash（哈希）</h3><p>键值对集合，适合存储对象，类似于<code>java</code>中的<code>map</code>；每个<code>hash</code>可以存储<code>2^32 -1</code> 键值对（40多亿）</p><h4 id="命令-1" tabindex="-1"><a class="header-anchor" href="#命令-1" aria-hidden="true">#</a> 命令</h4><ul><li><code>hset key field value</code>：将哈希表<code>key</code>中的字段<code>field</code>的值设为<code>value</code></li><li><code>hget key field</code>：获取存储在哈希表中指定字段的值</li><li><code>hmset key field1 value1 [field2 value2]</code>：同时将多个<code>field-value</code>（域-值）对设置到哈希表<code>key</code>中</li><li><code>hmget key field1 [field2]</code>：获取所有给定字段的值</li><li><code>hgetall key</code>：获取在哈希表中指定<code>key</code>的所有字段和值</li><li><code>hdel key field1 [field2]</code>：删除一个或者多个哈希表字段</li><li><code>hlen key</code>：获取哈希表中字段的数量</li><li><code>hexists key field</code>：查看哈希表<code>key</code>中，指定的字段是否存在</li><li><code>hkeys key</code>：获取哈希表中所有<code>field</code>的值</li><li><code>hvals key</code>：获取哈希表中所有<code>value</code>的值</li><li><code>hincrby key field increment</code>：哈希表<code>key</code>中指定字段的整数值加上增量<code>increment</code></li><li><code>hincrbyfloat key field increment</code>：哈希表<code>key</code>中指定字段的浮点数值加上增量<code>increment</code></li><li><code>hsetnx key field value</code>：只有在字段<code>field</code>不存在时，设置哈希表字段的值</li></ul><h3 id="list-列表" tabindex="-1"><a class="header-anchor" href="#list-列表" aria-hidden="true">#</a> List（列表）</h3><p><code>Redis</code>列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。</p><ul><li><code>lpush</code>从左边（首）插入，<code>rpush</code>从右边（尾）插入</li><li><code>lpop</code>从左边移除元素并返回该元素，<code>rpop</code>从右边移除元素并返回该元素</li></ul><p>列表最多可存储<code>2^32 - 1</code>元素(每个列表可存储40多亿)。</p><h4 id="命令-2" tabindex="-1"><a class="header-anchor" href="#命令-2" aria-hidden="true">#</a> 命令</h4><ul><li><code>lpush key value[value...]</code>：将一个或多个值插入到列表头部</li><li><code>rpush key value[value...]</code>：将一个或多个值插入到列表尾部</li><li><code>lrange key start stop</code>：获取队列指定范围内的元素</li><li><code>lpop key</code>：移出并获取列表的第一个元素</li><li><code>rpop key</code>：移除列表的最后一个元素，返回值为移除的元素</li><li><code>lindex key index</code>：按照索引下标获得元素，也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。</li><li><code>llen key</code>：获取列表长度</li><li><code>lrem key count value</code>：删除<code>count</code>个<code>value</code></li><li><code>ltrim key start stop</code>：对一个列表进行修剪(<code>trim</code>)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除（<strong>闭区间</strong>）</li><li><code>rpoplpush source destination</code>：移除列表的最后一个元素，并将该元素添加到了另一个列表并返回（尾出头入）</li><li><code>lset key index value</code>：将<code>key</code>的<code>index</code>位置设置为<code>value</code></li><li><code>linsert key before/after 【point】 value</code>：在列表的元素前或者后插入元素</li></ul><h4 id="性能" tabindex="-1"><a class="header-anchor" href="#性能" aria-hidden="true">#</a> 性能</h4><ol><li>如果键不存在，则创建新的链表；</li><li>如果键已存在，新增内容；</li><li>如果值全部移除，对应的键也就消失了；</li><li>链表的操作头和尾效率都极高，但假如是对中间元素进行操作，效率就很惨淡了。</li></ol><h3 id="set-集合" tabindex="-1"><a class="header-anchor" href="#set-集合" aria-hidden="true">#</a> Set（集合）</h3><p><code>Redis</code>的<code>Set</code>是<code>String</code>类型的无序集合，集合成员是唯一的。集合是通过哈希表（<code>HashTable</code>）实现的，所以添加、删除、查找的复杂度都是 <code>O(1)</code>。集合中最大的成员数为<code>2^32 - 1</code>( 每个集合可存储40多亿个成员)。</p><h4 id="命令-3" tabindex="-1"><a class="header-anchor" href="#命令-3" aria-hidden="true">#</a> 命令</h4><ul><li><code>sadd key member[member...]</code>：集合中添加一个或者多个成员（无序）</li><li><code>smembers key</code>：返回集合中的所有成员</li><li><code>sismember key member</code>：判断<code>member</code>元素是否是集合<code>key</code>的成员</li><li><code>scard key</code>：获取集合的成员数</li><li><code>srem key member[member...]</code>：删除集合中的一个或者多个元素</li><li><code>srandmember key [count]</code>：返回集合中一个或多个随机数---------适合做挖财项目</li><li><code>spop key</code>：移除并返回集合中的一个随机元素</li><li><code>smove source destination member</code>：将<code>member</code>元素从<code>source</code>集合移动到<code>destination</code></li></ul><h4 id="数学集合类" tabindex="-1"><a class="header-anchor" href="#数学集合类" aria-hidden="true">#</a> 数学集合类</h4><ul><li><code>sdiff key1 [key2]</code>：返回第一个集合与其他集合之间的差异</li><li><code>sinter key1 [key2]</code>：返回给定所有集合的交集</li><li><code>sunion key1 [key2]</code>：返回所有给定集合的并集</li></ul><h3 id="zset-sorted-set有序集合" tabindex="-1"><a class="header-anchor" href="#zset-sorted-set有序集合" aria-hidden="true">#</a> zset(sorted set有序集合)</h3><p><code>Redis</code>的<code>zset</code>和<code>set</code>一样也是<code>string</code>类型元素的集合，且不允许重复的成员。不同的是每个元素都会关联一个<code>double</code>类型的分数。</p><p><code>redis</code>正是通过分数来为集合中的成员进行从小到大的排序。<code>zset</code>的成员是唯一的，但分数(<code>score</code>)却可以重复。添加元素到集合，元素在集合中存在则更新对应<code>score</code>。</p><h4 id="命令-4" tabindex="-1"><a class="header-anchor" href="#命令-4" aria-hidden="true">#</a> 命令</h4><ul><li><code>zadd key score1 member1 [score2 member2]</code>：向有序集合添加一个或者多个成员，或者更新已存在成员的分数</li><li><code>ZRANGE key start stop [WITHSCORES]</code>：通过索引区间返回有序集合指定区间内的成员（是否包含分数信息）</li><li><code>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT]</code>：通过分数返回范围内的<code>member</code>成员（是否包含分数），其中“（”表示不包含；<code>limit</code>作用是返回限制 （<code>limit start count</code>）</li></ul><p><strong>示例：</strong><code>zrangebyscore zset01 60 （90 withscores limit 2 2</code>：从<code>zset01</code>中选取分数大于等于60，小于90的从第二个索引开始往后两个的成员</p><ul><li><code>zrem key member[member...]</code>：移除有序集合中的一个或多个成员</li><li><code>zcard key</code>：获取有序集合的成员数</li><li><code>zcount key min max</code>：获取有序集合的大于<code>min</code>小于<code>max</code>的成员数</li><li><code>zrank key member</code>：获取<code>member</code>的索引</li><li><code>zscore key member</code>：获取有序集合的<code>member</code>的分数</li></ul><h4 id="rev" tabindex="-1"><a class="header-anchor" href="#rev" aria-hidden="true">#</a> REV</h4><ul><li><code>ZREVRANK key member</code>：返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序</li><li><code>ZREVRANGE key start stop [WITHSCORES]</code>：通过索引返回有序集中指定区间内的成员，分数从高到低</li><li><code>ZREVRANGEBYSCORE key max min [WITHSCORES]</code>：返回有序集中指定分数区间内的成员，分数从高到低排序</li></ul><p>2022年6月21日晚八点在技术群公布中奖结果，我也会私信你呦！</p>',38);function p(b,f){const o=t("ExternalLinkIcon");return a(),r("div",null,[n,e("ul",null,[e("li",null,[d("中文网站："),e("a",h,[d("http://www.redis.cn/"),c(o)])]),e("li",null,[d("英文网站："),e("a",k,[d("http://www.redis.io/"),c(o)])])]),y,e("blockquote",null,[e("p",null,[d("之前我们已经介绍过"),e("a",u,[d("Redis的安装"),c(o)]),d("，此处不再赘述。")])]),m])}const x=l(s,[["render",p],["__file","快速了解 Redis 的概念和命令.html.vue"]]);export{x as default};
