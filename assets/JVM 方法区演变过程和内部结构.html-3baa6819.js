const e=JSON.parse('{"key":"v-22a4dac2","path":"/cheetah/jvm/JVM%20%E6%96%B9%E6%B3%95%E5%8C%BA%E6%BC%94%E5%8F%98%E8%BF%87%E7%A8%8B%E5%92%8C%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84.html","title":"JVM 方法区演变过程和内部结构","lang":"zh-CN","frontmatter":{"title":"JVM 方法区演变过程和内部结构","icon":"storage","order":8,"category":["JVM"],"tag":["JVM","总结"],"description":"之前我们已经了解过“运行时数据区”的程序计数器、虚拟机栈、本地方法栈和堆空间，今天我们就来了解一下最后一个模块——方法区。 简介 创建对象时内存分配简图 《Java虚拟机规范》中明确说明：“尽管所有的方法区在逻辑上属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。” 虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/cheetah/jvm/JVM%20%E6%96%B9%E6%B3%95%E5%8C%BA%E6%BC%94%E5%8F%98%E8%BF%87%E7%A8%8B%E5%92%8C%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84.html"}],["meta",{"property":"og:site_name","content":"阿Q说代码"}],["meta",{"property":"og:title","content":"JVM 方法区演变过程和内部结构"}],["meta",{"property":"og:description","content":"之前我们已经了解过“运行时数据区”的程序计数器、虚拟机栈、本地方法栈和堆空间，今天我们就来了解一下最后一个模块——方法区。 简介 创建对象时内存分配简图 《Java虚拟机规范》中明确说明：“尽管所有的方法区在逻辑上属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。” 虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-04-03T08:02:23.000Z"}],["meta",{"property":"article:author","content":"阿Q"}],["meta",{"property":"article:tag","content":"JVM"}],["meta",{"property":"article:tag","content":"总结"}],["meta",{"property":"article:modified_time","content":"2023-04-03T08:02:23.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"JVM 方法区演变过程和内部结构\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-04-03T08:02:23.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"阿Q\\",\\"url\\":\\"https://app.yinxiang.com/fx/d1ae87df-aa4e-498e-bcf2-32013fd1f523\\"}]}"]]},"headers":[{"level":2,"title":"简介","slug":"简介","link":"#简介","children":[]},{"level":2,"title":"永久代、元空间","slug":"永久代、元空间","link":"#永久代、元空间","children":[{"level":3,"title":"直接内存","slug":"直接内存","link":"#直接内存","children":[]},{"level":3,"title":"方法区的大小","slug":"方法区的大小","link":"#方法区的大小","children":[]},{"level":3,"title":"jvisualvm","slug":"jvisualvm","link":"#jvisualvm","children":[]},{"level":3,"title":"高水位线","slug":"高水位线","link":"#高水位线","children":[]}]},{"level":2,"title":"内部结构","slug":"内部结构","link":"#内部结构","children":[{"level":3,"title":"类型信息","slug":"类型信息","link":"#类型信息","children":[]},{"level":3,"title":"域（Field）信息","slug":"域-field-信息","link":"#域-field-信息","children":[]},{"level":3,"title":"方法（Method）信息","slug":"方法-method-信息","link":"#方法-method-信息","children":[]},{"level":3,"title":"non-final 的类变量","slug":"non-final-的类变量","link":"#non-final-的类变量","children":[]},{"level":3,"title":"运行时常量池","slug":"运行时常量池","link":"#运行时常量池","children":[]}]},{"level":2,"title":"演进细节","slug":"演进细节","link":"#演进细节","children":[{"level":3,"title":"演变示例图","slug":"演变示例图","link":"#演变示例图","children":[]},{"level":3,"title":"为什么要将永久代替换为元空间呢?","slug":"为什么要将永久代替换为元空间呢","link":"#为什么要将永久代替换为元空间呢","children":[]},{"level":3,"title":"StringTable 为什么要调整","slug":"stringtable-为什么要调整","link":"#stringtable-为什么要调整","children":[]}]},{"level":2,"title":"垃圾回收","slug":"垃圾回收","link":"#垃圾回收","children":[{"level":3,"title":"类型判定","slug":"类型判定","link":"#类型判定","children":[]}]}],"git":{"createdTime":1680508943000,"updatedTime":1680508943000,"contributors":[{"name":"zhangxiaoQ","email":"1004387130@qq.com","commits":1}]},"readingTime":{"minutes":10.62,"words":3185},"filePathRelative":"cheetah/jvm/JVM 方法区演变过程和内部结构.md","localizedDate":"2023年4月3日","autoDesc":true}');export{e as data};
