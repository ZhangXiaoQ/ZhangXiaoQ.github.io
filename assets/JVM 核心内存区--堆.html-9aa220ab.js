import{_ as a,W as n,X as e,a2 as s}from"./framework-a9f5de78.js";const o={},c=s(`<p>端午佳节一下子就过完了，大家是不是还沉迷在假期的欢乐气氛中无法自拔？今天阿Q为大家准备了上好的“醒酒菜”——<code>JVM</code>运行时数据区的核心内存区——堆。</p><h3 id="堆的概述" tabindex="-1"><a class="header-anchor" href="#堆的概述" aria-hidden="true">#</a> 堆的概述</h3><p>一般来说：</p><ul><li>一个<code>Java</code>程序的运行对应一个进程；</li><li>一个进程对应着一个<code>JVM</code>实例（<code>JVM</code>的启动由引导类加载器加载启动），同时也对应着多个线程；</li><li>一个<code>JVM</code>实例拥有一个运行时数据区（<code>Runtime</code>类，为饿汉式单例类）；</li><li>一个运行时数据区中的堆和方法区是多线程共享的，而本地方法栈、虚拟机栈、程序计数器是线程私有的。</li></ul><p>堆空间差不多是最大的内存空间，也是运行时数据区最重要的内存空间。堆可以处于物理上不连续的内存空间，但在逻辑上它应该被视为连续的。</p><p>在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。堆，是<code>GC</code>(<code>Garbage Collection</code>，垃圾收集器)执行垃圾回收的重点区域。</p><h3 id="堆内存大小设置" tabindex="-1"><a class="header-anchor" href="#堆内存大小设置" aria-hidden="true">#</a> 堆内存大小设置</h3><p>堆一旦被创建，它的大小也就确定了，初始内存默认为电脑物理内存大小的<code>1/64</code>，最大内存默认为电脑物理内存的<code>1/4</code>，但是堆空间的大小是可以调节，接下来我们来演示一下。</p><h4 id="准备工具" tabindex="-1"><a class="header-anchor" href="#准备工具" aria-hidden="true">#</a> 准备工具</h4><p><code>JDK</code>自带内存分析的工具:在已安装<code>JDK</code>的<code>bin</code>目录下找到<code>jvisualvm.exe</code>。打开该软件，下载插件<code>Visual GC</code>，一定要点击检查最新版本，否则会导致安装失败。</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/64bbb779a10d4f19bb4e0415f7bb2579~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>安装完重启<code>jvisualvm</code></p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5975dddf501a49ab8bec412614e030be~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="代码样例" tabindex="-1"><a class="header-anchor" href="#代码样例" aria-hidden="true">#</a> 代码样例</h4><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HeapDemo</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;start...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;end...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="idea设置" tabindex="-1"><a class="header-anchor" href="#idea设置" aria-hidden="true">#</a> IDEA设置</h4><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d0206e4d9d34bb598b68332de50ec60~tplv-k3u1fbpfcp-zoom-1.image" alt="" loading="lazy"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/03bc9025c20e45639fa3cd7f6f147970~tplv-k3u1fbpfcp-zoom-1.image" alt="" loading="lazy"></p><ul><li><code>-Xms10m</code>用于表示堆区的起始内存为10m，等价于<code>-XX:InitialHeapSize</code>；</li><li><code>-Xmx10m</code>用于表示堆区的最大内存为10m，等价于<code>-XX:MaxHeapSize</code>；</li><li>其中<code>-X</code>是<code>JVM</code>的运行参数，<code>ms</code>是<code>memory start</code></li></ul><blockquote><p>通常会将<code>-Xms</code>和<code>-Xmx</code>两个参数配置相同的值，其目的就是为了能够在<code>java</code>垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能。</p></blockquote><h4 id="启动程序" tabindex="-1"><a class="header-anchor" href="#启动程序" aria-hidden="true">#</a> 启动程序</h4><p>启动程序之后去<code>jvisualvm</code>查看</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e1bdf2a4624d47a586f8e189fa075bd1~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>一旦堆区中的内存大小超过<code>-Xmx</code>所指定的最大内存时，将会抛出<code>OOM</code>(<code>Out Of MemoryError</code>)异常。</p><h3 id="堆的分代" tabindex="-1"><a class="header-anchor" href="#堆的分代" aria-hidden="true">#</a> 堆的分代</h3><p>存储在<code>JVM</code>中的<code>java</code>对象可以被划分为两类：</p><ul><li>一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速；</li><li>另一类是生命周期非常长，在某些情况下还能与<code>JVM</code>的生命周期保持一致；</li></ul><h4 id="堆区分代" tabindex="-1"><a class="header-anchor" href="#堆区分代" aria-hidden="true">#</a> 堆区分代</h4><p>经研究表明<code>70%-99%</code>的对象属于临时对象，为了提高<code>GC</code>的性能，<code>Hotspot</code>虚拟机又将堆区进行了进一步划分。</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ffd0872055f4ad9bed7bb6bf2826114~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>如图所示，堆区又分为年轻代（<code>YoungGen</code>）和老年代（<code>OldGen</code>）；其中年轻代又分为伊甸园区（<code>Eden</code>）和幸存者区（<code>Survivor</code>）；幸存者区分为幸存者0区（<code>Survivor0，S0</code>）和幸存者1区（<code>Survivor1，S1</code>），有时也叫<code>from</code>区和<code>to</code>区。</p><blockquote><p>分代完成之后，GC时主要检测新生代<code>Eden</code>区。</p></blockquote><p><strong>统一概念：</strong><br> 新生区&lt;=&gt;新生代&lt;=&gt;年轻代<br> 养老区&lt;=&gt;老年区&lt;=&gt;老年代</p><p>几乎所有的<code>Java</code>对象都是在<code>Eden</code>区被<code>new</code>出来的，有的大对象在该区存不下可直接进入老年代。绝大部分的<code>Java</code>对象都销毁在新生代了（<code>IBM</code>公司的专门研究表明，新生代80%的对象都是“朝生夕死”的）。</p><h4 id="新生代与老年代在堆结构的占比" tabindex="-1"><a class="header-anchor" href="#新生代与老年代在堆结构的占比" aria-hidden="true">#</a> 新生代与老年代在堆结构的占比</h4><ul><li>默认参数<code>-XX:NewRatio=2</code>，表示新生代占1，老年代占2，新生代占整个堆的1/3；</li><li>可以修改<code>-XX:NewRatio=4</code>，表示新生代占1，老年代占4，新生代占整个堆的1/5;</li></ul><blockquote><p>该参数在开发中一般不会调整，如果生命周期长的对象偏多时可以选择调整。</p></blockquote><h4 id="eden与survivor在堆结构的占比" tabindex="-1"><a class="header-anchor" href="#eden与survivor在堆结构的占比" aria-hidden="true">#</a> Eden与Survivor在堆结构的占比</h4><p>在<code>HotSpot</code>中，<code>Eden</code>空间和另外两个<code>Survivor</code>空间所占的比例是8：1：1（测试的时候是6：1：1），开发人员可以通过选项<code>-XX:SurvivorRatio</code>调整空间比例，如<code>-XX:SurvivorRatio=8</code></p><blockquote><p>可以在<code>cmd</code>中通过<code>jps 查询进程号-&gt; jinfo -flag NewRatio(SurvivorRatio) + 进程号</code> 查询配置信息</p></blockquote><p><code>-Xmn</code>设置新生代最大内存大小（默认就好），如果既设置了该参数，又设置了<code>NewRatio</code>的值，则以该参数设置为准。</p><h4 id="查看设置的参数" tabindex="-1"><a class="header-anchor" href="#查看设置的参数" aria-hidden="true">#</a> 查看设置的参数</h4><p>以上边的代码为例：设置启动参数<code>-XX:+PrintGCDetails</code>；可在cmd窗口中输入<code>jps</code>查询进程号，然后通过<code>jstat -gc 进程id</code>指令查看进程的内存使用情况。</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0acb8f6a5a1949918eb9d87a8d7d2666~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="图解对象分配过程" tabindex="-1"><a class="header-anchor" href="#图解对象分配过程" aria-hidden="true">#</a> 图解对象分配过程</h3><h4 id="对象分配过程" tabindex="-1"><a class="header-anchor" href="#对象分配过程" aria-hidden="true">#</a> 对象分配过程</h4><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7da8970ce38b426185883148ccf37b71~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol><li>new的对象先放伊甸园区，此区有大小限制；</li><li>当伊甸园的空间填满时，程序继续创建对象，<code>JVM</code>的垃圾回收器将对伊甸园区进行垃圾回收（<code>Minor GC</code>，也叫<code>YGC</code>)：将伊甸园区中的不再被其他对象所引用的对象进行销毁，将未被销毁的对象移动到幸存者0区并分配<code>age</code>；</li><li>然后再加载新的对象放到伊甸园区；</li><li>如果再次触发垃圾回收，将此次未被销毁的对象和上一次放在幸存者0区且此次也未被销毁的对象一齐移动到幸存者一区，此时新对象的<code>age</code>为1，上次的对象的<code>age</code>加1变为2；</li><li>如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区，<code>age</code>也随之增加；</li><li>默认当<code>age</code>为15时，未被回收的对象将移动到老年区。可以通过设置参数来更改默认配置：<code>-XX:MaxTenuringThreshold=&lt;N&gt;</code>；该过程称为晋升（<code>promotion</code>)；</li><li>在养老区，相对悠闲，当老年区内存不足时，再次触发GC（<code>Major GC</code>），进行养老区的内存清理；</li><li>若养老区执行了<code>Major GC</code>之后发现依然无法进行对象的保存，就会产生<code>OOM</code>异常。</li></ol><blockquote><p>S0，S1满时不会触发<code>YGC</code>，但是<code>YGC</code>会回收S0，S1的对象。</p></blockquote><p><strong>总结</strong></p><ul><li>针对幸存者s0，s1区：复制之后有交换，谁空谁是to；</li><li>关于垃圾回收：频繁在新生区收集，很少在养老区收集，几乎不再永久区/元空间收集。</li></ul><h4 id="对象特殊情况分配过程" tabindex="-1"><a class="header-anchor" href="#对象特殊情况分配过程" aria-hidden="true">#</a> 对象特殊情况分配过程</h4><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5f65059b65584942bb177fa69acea5d0~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol><li>新对象申请内存，如果<code>Eden</code>放的下，则直接存入<code>Eden</code>；如果存不下则进行<code>YGC</code>；</li><li><code>YGC</code>之后如果能存下则放入<code>Eden</code>，如果还存不下（为超大对象），则尝试存入<code>Old</code>区；</li><li>如果<code>Old</code>区可以存放，则存入；如果不能存入，则进行<code>Full GC</code>；</li><li><code>Full GC</code>之后如果可以存入<code>Old</code>区，则存入；如果内存空间还不够，则<code>OOM</code>；</li><li>图右侧为<code>YGC</code>的流程图：当<code>YGC</code>之后未销毁的对象放入幸存者区，此时如果幸存者区的空间可以装下该对象，则存入幸存者区，否则，直接存入老年代；</li><li>当在幸存者区的对象超过阈值时，可以晋升为老年代，未达到阈值的依旧在幸存者区复制交换。</li></ol><h4 id="内存分配策略" tabindex="-1"><a class="header-anchor" href="#内存分配策略" aria-hidden="true">#</a> 内存分配策略</h4><p>针对不同年龄段的对象分配原则如下：</p><ol><li>优先分配到<code>Eden</code>；</li><li>大对象直接分配到老年代：尽量避免程序中出现过多的大对象；</li><li>长期存活的对象分配到老年代；</li><li>动态对象年龄判断：如果<code>Survivor</code>区中相同年龄的所有对象大小的总和大于<code>Survivor</code>空间的一半，年龄大于或等于该年龄的对象可以直接进入到老年代。无需等到<code>MaxTenuringThreshold</code>中要求的年龄；</li></ol><h4 id="数值变小原理" tabindex="-1"><a class="header-anchor" href="#数值变小原理" aria-hidden="true">#</a> 数值变小原理</h4><p>代码样例，设置参数:<code>-Xms600m，-Xmx600m</code></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HeapSpaceInitial</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>

        <span class="token comment">//返回Java虚拟机中的堆内存总量</span>
        <span class="token keyword">long</span> initialMemory <span class="token operator">=</span> <span class="token class-name">Runtime</span><span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">totalMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">1024</span> <span class="token operator">/</span> <span class="token number">1024</span><span class="token punctuation">;</span>
        <span class="token comment">//返回Java虚拟机试图使用的最大堆内存量</span>
        <span class="token keyword">long</span> maxMemory <span class="token operator">=</span> <span class="token class-name">Runtime</span><span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">maxMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">1024</span> <span class="token operator">/</span> <span class="token number">1024</span><span class="token punctuation">;</span>

        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;-Xms : &quot;</span> <span class="token operator">+</span> initialMemory <span class="token operator">+</span> <span class="token string">&quot;M&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;-Xmx : &quot;</span> <span class="token operator">+</span> maxMemory <span class="token operator">+</span> <span class="token string">&quot;M&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">//执行结果</span>
<span class="token operator">-</span><span class="token class-name">Xms</span> <span class="token operator">:</span> <span class="token number">575</span>M
<span class="token operator">-</span><span class="token class-name">Xmx</span> <span class="token operator">:</span> <span class="token number">575</span>M
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>明明设置的600M，怎么变成575M了呢？这是因为在堆内存存取数据时，新生代里边只有伊甸园和幸存者1区或者是幸存者2区存储对象，所以会少一个幸存者区的内存空间。</p><h3 id="gc" tabindex="-1"><a class="header-anchor" href="#gc" aria-hidden="true">#</a> GC</h3><p><code>JVM</code>进行<code>GC</code>时，并非每次都对新生代、老年代、方法区（永久代、元空间）这三个区域一起回收，大部分回收是指新生代。</p><p>针对<code>HotSpot VM</code>的实现，它里面的<code>GC</code>按照回收区域又分为两大种类型：一种是部分收集（<code>Partial GC</code>），一种是整堆收集（<code>Full GC</code>）</p><h4 id="partial-gc" tabindex="-1"><a class="header-anchor" href="#partial-gc" aria-hidden="true">#</a> Partial GC</h4><p>部分收集：不是完整收集整个<code>Java</code>堆的垃圾收集。其中又分为：</p><ul><li>新生代收集（Minor GC/Young GC）：只是新生代的垃圾收集；</li><li>老年代收集（Major GC/Old GC）：只是老年代的垃圾收集；</li><li>混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集，只有<code>G1 GC</code> （按照<code>region</code>划分新生代和老年代的数据）会有这种行为。</li></ul><p>目前，只有<code>CMS GC</code>会有单独收集老年代的行为；很多时候<code>Major GC</code>会和<code>Full GC</code> 混淆使用，需要具体分辨是老年代回收还是整堆回收。</p><h4 id="full-gc" tabindex="-1"><a class="header-anchor" href="#full-gc" aria-hidden="true">#</a> Full GC</h4><p>整堆收集（<code>Full GC</code>）：整个<code>java</code>堆和方法区的垃圾收集。</p><h4 id="触发机制" tabindex="-1"><a class="header-anchor" href="#触发机制" aria-hidden="true">#</a> 触发机制</h4><h5 id="年轻代gc-minor-gc-触发机制" tabindex="-1"><a class="header-anchor" href="#年轻代gc-minor-gc-触发机制" aria-hidden="true">#</a> 年轻代GC（Minor GC）触发机制</h5><ol><li>当年轻代空间不足时，就会触发<code>Minor GC</code>，这里的年轻代满指的是<code>Eden</code>代满，<code>Survivor</code>满不会引发<code>GC</code>。(每次<code>Minor GC</code>会清理年轻代的内存，<code>Survivor</code>是被动<code>GC</code>，不会主动<code>GC</code>)</li><li>因为<code>Java</code>对象大多都具备“朝生夕灭”的特性，所以<code>Minor GC</code>非常频繁，一般回收速度也比较快。</li><li><code>Minor GC</code>会引发<code>STW</code>（<code>Stop The World</code>），暂停其他用户的线程，等垃圾回收结束，用户线程才恢复运行。</li></ol><h5 id="老年代gc-major-gc-full-gc-触发机制" tabindex="-1"><a class="header-anchor" href="#老年代gc-major-gc-full-gc-触发机制" aria-hidden="true">#</a> 老年代GC(Major GC/Full GC)触发机制</h5><ol><li>指发生在老年代的<code>GC</code>，对象从老年代消失时，<code>Major GC</code>或者<code>Full GC</code>发生了；</li><li>出现了<code>Major GC</code>，经常会伴随至少一次的<code>Minor GC</code>（不是绝对的，在<code>Parallel Scavenge</code>收集器的收集策略里就有直接进行<code>Major GC</code>的策略选择过程），也就是老年代空间不足时，会先尝试触发<code>Minor GC</code>。如果之后空间还不足，则触发<code>Major GC</code>；</li><li><code>Major GC</code>速度一般会比<code>Minor GC</code>慢10倍以上，<code>STW</code>时间更长；</li><li>如果<code>Major GC</code>后，内存还不足，就报<code>OOM</code>了。</li></ol><h5 id="full-gc触发机制" tabindex="-1"><a class="header-anchor" href="#full-gc触发机制" aria-hidden="true">#</a> Full GC触发机制</h5><p>触发Full GC执行的情况有以下五种：</p><ol><li>调用<code>System.gc()</code>时，系统建议执行<code>Full GC</code>，但是不必然执行；</li><li>老年代空间不足；</li><li>方法区空间不足；</li><li>通过<code>Minor GC</code>后进入老年代的平均大小小于老年代的可用内存；</li><li>由<code>Eden</code>区，<code>Survivor S0</code>（<code>from</code>）区向<code>S1</code>（<code>to</code>）区复制时，对象大小大于<code>To Space</code>可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小。</li></ol><blockquote><p><code>Full GC</code>是开发或调优中尽量要避免的，这样暂停时间会短一些。</p></blockquote>`,78),t=[c];function i(d,p){return n(),e("div",null,t)}const u=a(o,[["render",i],["__file","JVM 核心内存区--堆.html.vue"]]);export{u as default};
