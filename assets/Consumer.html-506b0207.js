const e=JSON.parse('{"key":"v-49143ff0","path":"/cheetah/java/Consumer.html","title":"如果还不懂如何使用 Consumer 接口，来公司我当面给你讲！","lang":"zh-CN","frontmatter":{"title":"如果还不懂如何使用 Consumer 接口，来公司我当面给你讲！","icon":"java","order":7,"category":["java"],"tag":["consumer","supplier","function","predicate"],"description":"背景 没错，我还在做 XXXX 项目，还在与第三方对接接口，不同的是这次是对自己业务逻辑的处理。 在开发过程中我遇到这么一个问题： 表结构： 一张主表A ，一张关联表B ，表 A 中存储着表 B 记录的状态。 场景 第一步创建主表数据，插入A表；第二步调用第三方接口插入B表同时更新A表的状态。此时大家应该都会想到在进行第二步的时候需要做好数据的幂等性。...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/cheetah/java/Consumer.html"}],["meta",{"property":"og:site_name","content":"阿Q说代码"}],["meta",{"property":"og:title","content":"如果还不懂如何使用 Consumer 接口，来公司我当面给你讲！"}],["meta",{"property":"og:description","content":"背景 没错，我还在做 XXXX 项目，还在与第三方对接接口，不同的是这次是对自己业务逻辑的处理。 在开发过程中我遇到这么一个问题： 表结构： 一张主表A ，一张关联表B ，表 A 中存储着表 B 记录的状态。 场景 第一步创建主表数据，插入A表；第二步调用第三方接口插入B表同时更新A表的状态。此时大家应该都会想到在进行第二步的时候需要做好数据的幂等性。..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-04-04T08:56:36.000Z"}],["meta",{"property":"article:author","content":"阿Q"}],["meta",{"property":"article:tag","content":"consumer"}],["meta",{"property":"article:tag","content":"supplier"}],["meta",{"property":"article:tag","content":"function"}],["meta",{"property":"article:tag","content":"predicate"}],["meta",{"property":"article:modified_time","content":"2023-04-04T08:56:36.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"如果还不懂如何使用 Consumer 接口，来公司我当面给你讲！\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-04-04T08:56:36.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"阿Q\\",\\"url\\":\\"https://mp.weixin.qq.com/mp/profile_ext?action=home&__biz=MzI5MDg2NjEzNA==#wechat_redirect\\"}]}"]]},"headers":[{"level":2,"title":"背景","slug":"背景","link":"#背景","children":[{"level":3,"title":"场景","slug":"场景","link":"#场景","children":[]},{"level":3,"title":"代码实现","slug":"代码实现","link":"#代码实现","children":[]},{"level":3,"title":"更改之后的伪代码","slug":"更改之后的伪代码","link":"#更改之后的伪代码","children":[]}]},{"level":2,"title":"函数式接口","slug":"函数式接口","link":"#函数式接口","children":[{"level":3,"title":"@FunctionalInterface","slug":"functionalinterface","link":"#functionalinterface","children":[]},{"level":3,"title":"Consumer","slug":"consumer","link":"#consumer","children":[]},{"level":3,"title":"Supplier","slug":"supplier","link":"#supplier","children":[]},{"level":3,"title":"Function","slug":"function","link":"#function","children":[]},{"level":3,"title":"Predicate","slug":"predicate","link":"#predicate","children":[]}]}],"git":{"createdTime":1680598596000,"updatedTime":1680598596000,"contributors":[{"name":"ZhangXiaoQ","email":"1004387130@qq.com","commits":1}]},"readingTime":{"minutes":7.82,"words":2346},"filePathRelative":"cheetah/java/Consumer.md","localizedDate":"2023年4月4日","autoDesc":true}');export{e as data};
