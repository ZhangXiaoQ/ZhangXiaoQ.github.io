import{_ as e,W as d,X as o,a2 as c}from"./framework-a9f5de78.js";const i={},a=c(`<p>在往期的文章中我们已经对<code>Redis</code>的概念和基本命令进行了讲解，今天我们来看下它的配置文件，<code>Redis</code>的配置文件在我们的开发和实际应用中起着非常重要的作用。</p><p>我们可以在安装目录下找到<code>redis.conf</code>配置文件，通过<code>vim</code>命令进行查看，为了防止配置文件进行更改，大家在使用前一定要备份一下！</p><p>本文<code>Redis</code>的版本为<code>5.0.7</code></p><h2 id="units" tabindex="-1"><a class="header-anchor" href="#units" aria-hidden="true">#</a> UNITS</h2><div class="language-xml line-numbers-mode" data-ext="xml"><pre class="language-xml"><code>1k =&gt; 1000 bytes
1kb =&gt; 1024 bytes
1m =&gt; 1000000 bytes
1mb =&gt; 1024*1024 bytes
1g =&gt; 1000000000 bytes
1gb =&gt; 1024*1024*1024 bytes
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>单位不区分大小写，只支持bytes</p></blockquote><h2 id="includes" tabindex="-1"><a class="header-anchor" href="#includes" aria-hidden="true">#</a> INCLUDES</h2><p>和<code>structs2</code>配置文件类似，可以通过<code>includes</code>包含。<code>redis.conf</code>可以作为总闸，包含其他。</p><div class="language-xml line-numbers-mode" data-ext="xml"><pre class="language-xml"><code>include /path/to/local.conf
include /path/to/other.conf
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="modules" tabindex="-1"><a class="header-anchor" href="#modules" aria-hidden="true">#</a> MODULES</h2><div class="language-xml line-numbers-mode" data-ext="xml"><pre class="language-xml"><code>loadmodule /path/to/my_module.so
loadmodule /path/to/other_module.so
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><code>Redis</code>可以通过<code>loadmodule</code>选项在启动时加载模块，若服务端无法加载模块，服务端会停止。可以通过多个<code>loadmodule</code>选项加载多个模块。</p><h2 id="network" tabindex="-1"><a class="header-anchor" href="#network" aria-hidden="true">#</a> NETWORK</h2><ul><li><strong>bind 127.0.0.1</strong>：默认情况下，如果未指定“bind”配置指令，<code>Redis</code>将侦听服务器上所有可用网络接口的连接。</li></ul><p>可以使用“bind”配置指令，后跟一个或多个IP地址，只侦听一个或多个选定接口。 <strong>例如：</strong> bind 192.168.1.100 10.0.0.1</p><p>当设置多个<code>bind</code>地址后，<code>Redis</code>内部会维护多个<code>Socket</code>，每个<code>Socket</code>用于一个<code>network interface</code>。</p><ul><li><strong>protected-mode yes</strong>：此选项默认开启。</li></ul><p>当<code>Redis</code>服务端未使用<code>bind</code>选项显式指定要监听的<code>network interface</code>，并且未设置密码，<code>Redis</code>服务端只会接受来自<code>127.0.0.1</code>和<code>::1</code>的客户端以及<code>Unix</code>域的<code>Socket</code>进行连接。</p><ul><li><strong>port 6379</strong>：用于设置<code>Redis</code>监听的<code>TCP</code>端口，默认为6379，设置为0表示不监听<code>TCP</code>端口</li><li><strong>timeout 0</strong>：空闲多少秒之后关闭连接，“0”表示不关闭</li><li><strong>tcp-keepalive 300</strong>：单位为秒，如果为0，则不会进行<code>keepalive</code>检测，建议设置成60</li><li><strong>tcp-backlog 511</strong>：设置<code>tcp</code>的<code>backlog</code>，<code>backlog</code>其实是一个连接队列。</li></ul><blockquote><p><code>backlog</code>队列总和 = 未完成三次握手队列 + 已经完成三次握手队列</p></blockquote><p>在高并发环境下需要一个高<code>backlog</code>值来避免慢客户端连接问题。</p><p><strong>注意</strong>：<code>Linux</code>内核会将这个值减小到<code>/proc/sys/net/core/somaxconn</code>的值，所以需要确认增大<code>somaxconn</code>和<code>tcp_max_syn_backlog</code>两个值来达到想要的效果。</p><h2 id="general" tabindex="-1"><a class="header-anchor" href="#general" aria-hidden="true">#</a> GENERAL</h2><h3 id="daemonize" tabindex="-1"><a class="header-anchor" href="#daemonize" aria-hidden="true">#</a> daemonize</h3><p><code>Redis</code>采用的是单进程多线程的模式，<code>daemonize</code>是用来指定<code>redis</code>是否要用守护线程的方式启动。默认情况下，<code>Redis</code>不作为守护进程运行。如果需要，请使用“是”。</p><div class="language-xml line-numbers-mode" data-ext="xml"><pre class="language-xml"><code>#daemonize no 
//当前界面将进入redis的命令行界面，
exit强制退出或者关闭连接工具(putty，
xshell等)都会导致redis进程退出。

daemonize yes     
//代表开启守护进程模式。在该模式下，
redis 会在后台运行，并将进程 pid 号写入
至 redis.conf 选项 pidfile 设置的文件中，
此时 redis 将一直运行，除非手动kill该进程。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="supervised-no" tabindex="-1"><a class="header-anchor" href="#supervised-no" aria-hidden="true">#</a> supervised no</h3><p>当你通过<code>upstart</code>或者<code>systemd</code>运行<code>Redis</code>时，<code>Redis</code>可以和你的<code>supervision tree</code>进行交互，可选的选项为：</p><ul><li>no 无交互（默认）</li><li>upstart 通过向<code>Redis</code>发送<code>SIGSTOP</code>信号来通知<code>upstart</code></li><li>systemd 通过向<code>$NOTIFY_SOCKET</code>写入<code>READY=1</code>来通知<code>systemd</code></li><li>auto 通过是否设置了<code>UPSTART_JOB</code>或者<code>NOTIFY_SOCKET</code>环境变量来决定选项为 <code>upstart</code>或者<code>systemd</code></li></ul><h3 id="pidfile" tabindex="-1"><a class="header-anchor" href="#pidfile" aria-hidden="true">#</a> pidfile</h3><div class="language-xml line-numbers-mode" data-ext="xml"><pre class="language-xml"><code>pidfile /var/run/redis_6379.pid //进程pid文件
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="loglevel-notice" tabindex="-1"><a class="header-anchor" href="#loglevel-notice" aria-hidden="true">#</a> loglevel notice</h3><p>指定服务器日志级别：从上到下依次减少</p><ul><li><code>debug</code>：大量信息，对开发/测试有用</li><li><code>verbose</code>：许多很少有用的信息，但不像调试级别那样混乱</li><li><code>notice</code>：适度冗长，可能是生产中需要的内容</li><li><code>warning</code>：只记录非常重要/关键的消息</li></ul><h3 id="logfile" tabindex="-1"><a class="header-anchor" href="#logfile" aria-hidden="true">#</a> logfile</h3><div class="language-xml line-numbers-mode" data-ext="xml"><pre class="language-xml"><code>logfile &quot;&quot;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>日志的名字，如果为空，<code>redis</code>给控制台标准输出，如果配置为守护进程方式运行，且设置了<code>logfile</code>为<code>stdout</code>，则日志将会发送给<code>/dev/null</code></p><h3 id="database" tabindex="-1"><a class="header-anchor" href="#database" aria-hidden="true">#</a> database</h3><div class="language-xml line-numbers-mode" data-ext="xml"><pre class="language-xml"><code>databases 16
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>系统默认的库16个，默认使用0库</p><h3 id="syslog" tabindex="-1"><a class="header-anchor" href="#syslog" aria-hidden="true">#</a> syslog</h3><ul><li><code>syslog-enabled no</code>：是否把日志输出到<code>syslog</code>中，系统日志默认是关着</li><li><code>syslog-ident redis</code>：指定<code>syslog</code>里的日志标志设备以<code>redis</code>开头</li><li><code>syslog-facility local0</code>：指定<code>syslog</code>设备，值可以是<code>USER</code>或<code>LOCAL0-LOCAL7</code>，默认使用<code>local0</code></li></ul><h2 id="security-安全" tabindex="-1"><a class="header-anchor" href="#security-安全" aria-hidden="true">#</a> Security （安全）</h2><div class="language-xml line-numbers-mode" data-ext="xml"><pre class="language-xml"><code>requirepass 12345!@#
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>设置<code>redis</code>连接密码，如果配置了连接密码，客户端在连接<code>redis</code>时需要通过<code>Auth &lt;password&gt; </code>命令提供密码，默认关闭。</p><p>如果设置完密码，<code>ping</code>就失败了，提示“NoAuth Authentication required”，加上<code>auth + 密码</code>就通了。</p><p><strong>要求必须auth + password 在任何命令之前</strong></p><blockquote><p><code>Redis</code>一般做的是缓存，不是安全，而且系统会认为<code>Linux</code>是在安全的环境下。</p></blockquote><h2 id="clients" tabindex="-1"><a class="header-anchor" href="#clients" aria-hidden="true">#</a> CLIENTS</h2><p><code>maxclients 10000</code>：最大连接数</p><p>设置<code>redis</code>同时可以与多少个客户端进行连接。默认情况下为<code>10000</code>个客户端。</p><p>当你无法设置进程文件句柄限制时，<code>redis</code>会设置为当前的文件句柄限制值减去<code>32</code>，因为<code>redis</code>会为自身内部处理逻辑留一些句柄出来。</p><p>如果达到了此限制，<code>redis</code>则会拒绝新的连接请求，并且向这些连接请求方发出<strong>max number of clients reached</strong>以作回应。</p><h2 id="memory-management" tabindex="-1"><a class="header-anchor" href="#memory-management" aria-hidden="true">#</a> MEMORY MANAGEMENT</h2><p>设置<code>redis</code>可以使用的内存量。一旦到达内存使用上限，<code>redis</code>将会试图移除内部数据，移除规则可以通过<code>maxmemory-policy</code>来指定。</p><p>如果<code>redis</code>无法根据移除规则来移除内存中的数据，或者设置了<strong>不允许移除</strong>，那么<code>redis</code>则会针对那些需要申请内存的指令返回错误信息，比如<code>SET</code>、<code>LPUSH</code>等。但是对于无内存申请的指令，仍然会正常响应，比如<code>GET</code>等。</p><p>如果你的<code>redis</code>是主<code>redis</code>（说明你的<code>redis</code>有从<code>redis</code>），那么在设置内存使用上限时，需要在系统中留出一些内存空间给同步队列缓存，只有在你设置的是“不移除”的情况下，才不用考虑这个因素。</p><h3 id="最大缓存" tabindex="-1"><a class="header-anchor" href="#最大缓存" aria-hidden="true">#</a> 最大缓存</h3><div class="language-xml line-numbers-mode" data-ext="xml"><pre class="language-xml"><code>#maxmemory <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bytes</span><span class="token punctuation">&gt;</span></span>
maxmemory 128MB
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>设置<code>maxmemory</code>和相对应的回收策略算法，设置最好为物理内存的<strong>3/4</strong>，或者比例更小，因为<code>redis</code>复制数据等其他服务时，也是需要缓存的。以防缓存数据过大致使<code>redis</code>崩溃，造成系统出错不可用。</p><p>牺牲一部分缓存数据，保存整体系统可用性。<code>redis</code>新的内存机制，会把<code>key</code>放在内存，<code>value</code>存放在<code>swap</code>区。</p><p>此配置需要和<strong>maxmemory-policy</strong>配合使用，当<code>redis</code>中内存数据达到<code>maxmemory</code>时，触发<strong>清除策略</strong>。在<strong>内存不足</strong>时，任何<code>write</code>操作(比如<code>set</code>，<code>lpush</code>等)都会触发<strong>清除策略</strong>的执行。</p><h4 id="实际环境" tabindex="-1"><a class="header-anchor" href="#实际环境" aria-hidden="true">#</a> 实际环境</h4><p>建议<code>redis</code>的所有物理机器的硬件配置保持一致(内存一致)，同时确保<code>master/replica</code>中<strong>maxmemory policy</strong>配置一致。</p><h4 id="内存满时" tabindex="-1"><a class="header-anchor" href="#内存满时" aria-hidden="true">#</a> 内存满时</h4><p>如果还接收到<code>set</code>命令，<code>redis</code>将先尝试剔除设置过<code>expire</code>信息的<code>key</code>，而不管该<code>key</code>的过期时间有没有到达。</p><p>在删除时，将按照过期时间进行删除，最早将要被过期的<code>key</code>将最先被删除。如果带有<code>expire</code>信息的<code>key</code>都删光了，内存还不够用，那么将返回错误。这样，<code>redis</code>将不再接收写请求，只接收<code>get</code>请求。</p><blockquote><p><code>maxmemory</code>的设置比较适合于把<code>redis</code>当作于类似<code>memcached</code>的缓存来使用。</p></blockquote><h2 id="memory-management-1" tabindex="-1"><a class="header-anchor" href="#memory-management-1" aria-hidden="true">#</a> MEMORY MANAGEMENT</h2><h3 id="最大缓存策略" tabindex="-1"><a class="header-anchor" href="#最大缓存策略" aria-hidden="true">#</a> 最大缓存策略</h3><p><strong>maxmemory-policy</strong>:</p><ul><li>volatile-lru：使用<code>LRU</code>（最近最少使用）算法移除<code>key</code>，只对设置了过期时间的键</li><li>allkeys-lru：使用<code>LRU</code>算法移除<code>key</code>（所有<code>key</code>）</li><li>volatile-lfu：对过期键使用 LFU（最不经常使用）近似算法</li><li>allkeys-lfu：对所有键使用 LFU 近似算法</li><li>volatile-random：在过期集合中移除随机的<code>key</code>，只对设置了过期时间的键</li><li>allkeys-random：移除随机的<code>key</code></li><li>volatile-ttl：移除那些<code>TTL</code>值最小的<code>key</code>，即那些最近要过期的<code>key</code></li><li>noeviction：不进行移除。针对写操作，只是返回错误信息（默认）（去公司观察维度，不应该选择这个）</li></ul><blockquote><p><code>LRU</code>算法、<code>LFU</code>算法或者<code>TTL</code>算法都是不是很精确算法，而是个近似算法。</p></blockquote><p><strong>使用策略规则：</strong></p><ol><li>如果数据呈现幂律分布，也就是一部分数据访问频率高，一部分数据访问频率低，则使用<code>allkeys-lru</code>。</li><li>如果数据呈现平等分布，也就是所有的数据访问频率都相同，则使用<code>allkeys-random</code>。</li></ol><h3 id="样本数量" tabindex="-1"><a class="header-anchor" href="#样本数量" aria-hidden="true">#</a> 样本数量</h3><p>设置样本数量，上边提到的算法都并非是精确的算法，而是估算值，所以你可以设置样本的大小。</p><div class="language-xml line-numbers-mode" data-ext="xml"><pre class="language-xml"><code>maxmemory-samples 5
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>默认值是 5，也就是说<code>Redis</code>随机挑出5个键，然后选出一个最符合条件的。对<code>LRU</code>来说5是比较合适的。10已经很接近于真正的<code>LRU</code>，但会消耗更多的<code>CPU</code>。3会更快但没有那么精确。</p><h3 id="副本忽略最大内存" tabindex="-1"><a class="header-anchor" href="#副本忽略最大内存" aria-hidden="true">#</a> 副本忽略最大内存</h3><div class="language-xml line-numbers-mode" data-ext="xml"><pre class="language-xml"><code>replica-ignore-maxmemory yes
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>从<code>Redis 5</code>开始，默认情况下，<code>replica</code>节点会忽略<code>maxmemory</code>设置（除非在发生<code>failover</code>后，此节点被提升为<code>master</code>节点）。</p><p>这意味着只有<code>master</code>才会执行过期删除策略，并且<code>master</code>在删除键之后会对<code>replica</code>发送<code>DEL</code>命令。</p><p>这个行为保证了<code>master</code>和<code>replicas</code>的一致性，并且这通常也是你需要的，但是若你的<code>replica</code>节点是可写的，或者你希望<code>replica</code>节点有不同的内存配置，并且你确保所有到<code>replica</code>写操作都幂等的，那么你可以修改这个默认的行为 （请确保你明白你在做什么）。</p><p><strong>注意</strong> 默认情况下<code>replica</code>节点不会执行过期策略，它有可能使用了超过<code>maxmemory</code>设定的值的内存。因此你需要监控<code>replicas</code>节点所在的机器并且确保在<code>master</code>节点到达配置的<code>maxmemory</code>大小时，<code>replicas</code>节点不会超过物理内存的大小。</p>`,85),s=[a];function l(n,r){return d(),o("div",null,s)}const m=e(i,[["render",l],["__file","Redis 的基础配置.html.vue"]]);export{m as default};
