import{_ as t,W as o,X as p,Y as n,Z as a,a0 as e,a2 as c,C as i}from"./framework-a9f5de78.js";const l={},d=n("p",null,[a("近期疫情形势严峻，情形不容乐观，周末也不敢出去浪了，躲在家里“葛优躺”。闲来无事，又翻了遍"),n("code",null,"Spring"),a("的源码。不翻不知道，一翻吓一跳，之前翻过的源码已经吃进了肚子里，再见亦是陌生人。")],-1),u=n("blockquote",null,[n("p",null,"个人建议：为了以后能快速的捡起某个知识点，最好的方法还是形成文档，下次有遗漏的时候，直接读文档，按之前的思路捋一遍，“干净又卫生”。")],-1),r={href:"https://mp.weixin.qq.com/s/cZuyQXj9bXD6knvs1xRPRA",target:"_blank",rel:"noopener noreferrer"},k=n("code",null,"javaer",-1),v=n("strong",null,"广播与监听",-1),b={href:"https://mp.weixin.qq.com/s/BAHJoxkxCv8wDkjg9tjbow",target:"_blank",rel:"noopener noreferrer"},m=n("p",null,"版本号：spring-framework-5.0.x",-1),h=c(`<h2 id="源码解析" tabindex="-1"><a class="header-anchor" href="#源码解析" aria-hidden="true">#</a> 源码解析</h2><p>为了实现广播与监听的功能，<code>Spring</code>为我们提供了两个重要的函数式接口：<code>ApplicationEventPublisher</code>和<code>ApplicationListener</code>。前者的<code>publishEvent()</code>方法为我们提供了发送广播的能力；后者的<code>onApplicationEvent()</code>方法为我们提供了监听并处理事件的能力。</p><p>接下来我们就来分析一下<code>spring</code>是如何运用这两种能力的。</p><p>不知道大家对单例对象的初始化调用过程是否熟悉？主要调用方法流程如下：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/520c2316875940de990f25e16144db2c~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="发送广播" tabindex="-1"><a class="header-anchor" href="#发送广播" aria-hidden="true">#</a> 发送广播</h3><p><code>applyBeanPostProcessorsBeforeInitialization</code>方法会去遍历该工厂创建的所有的<code>Bean</code>后置处理器，然后去依次执行后置处理器对应的<code>postProcessBeforeInitialization</code>方法。</p><p>在该方法的实现类中我们看到了两个熟悉的类名</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4739be26a60747aa95d79956f29344c0~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>不知道大家还记得不，这俩类是在<code>beanFactory</code>的准备工作过程中添加的两个<code>bean</code>的后置处理器，所以这个地方会依次去执行这两个类中的实现方法。</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/edbc266f8fd946f2aa9bee182ab9871b~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>由于<strong>蓝框</strong>中类的实现方法是默认实现按照原样返回的给定的<code>bean</code>，所以此处不用过多分析，我们重点来看下<strong>红框</strong>中类的方法实现。</p><p>该方法中最重要的是<code>invokeAwareInterfaces</code>方法，它的作用是检测对应的<code>bean</code>是否实现了某个<code>Aware</code>接口，如果实现了的话就去进行相关的调用。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>bean <span class="token keyword">instanceof</span> <span class="token class-name">ApplicationEventPublisherAware</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">ApplicationEventPublisherAware</span><span class="token punctuation">)</span> bean<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setApplicationEventPublisher</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>applicationContext<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们发现在<code>invokeAwareInterfaces</code>方法中出现了如上代码，这不就是和广播发送相关的吗？所以只要我们写一个类来实现<code>ApplicationEventPublisherAware</code>接口，就可以在该<code>bean</code>中注入一个<code>ApplicationEventPublisher</code>对象，也就获得了发送广播的能力。</p><h3 id="监听消息" tabindex="-1"><a class="header-anchor" href="#监听消息" aria-hidden="true">#</a> 监听消息</h3><p><code>applyBeanPostProcessorsAfterInitialization</code>方法<strong>也</strong>会去遍历该工厂创建的所有的<code>Bean</code>后置处理器，然后去依次执行后置处理器对应的<code>postProcessAfterInitialization</code>方法。</p><p>同样的，该方法的实现类中也有<code>ApplicationContextAwareProcessor</code>和<code>ApplicationListenerDetector</code>两个类，但是不同的是，前者的类的实现方法是默认实现按照原样返回的给定<code>bean</code>，而后者做了相关的处理。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">this</span><span class="token punctuation">.</span>applicationContext<span class="token punctuation">.</span><span class="token function">addApplicationListener</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">ApplicationListener</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span> bean<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上述代码是将实现了<code>ApplicationListener</code>接口的<code>bean</code>添加到监听器列表中，最终是保存在<code>AbstractApplicationEventMulticaster</code>的成员变量<code>defaultRetriever</code>的集合<code>applicationListeners</code>中。</p><blockquote><p>猜想：当发送广播消息时，就直接找到集合中的这些监听器，然后调用每个监听器的<code>onApplicationEvent</code>方法完成事件的处理。</p></blockquote><h3 id="案例分析" tabindex="-1"><a class="header-anchor" href="#案例分析" aria-hidden="true">#</a> 案例分析</h3><p>在<code>refresh()</code>的<code>finishRefresh()</code>方法中，</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token function">publishEvent</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ContextRefreshedEvent</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>发送一条事件类型为<code>ContextRefreshedEvent</code>的广播消息，用来代表<code>Spring</code>容器初始化结束。通过分析发现，该方法中最主要的就是如下代码：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">//真正的广播交给 applicationEventMulticaster 来完成</span>
<span class="token function">getApplicationEventMulticaster</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">multicastEvent</span><span class="token punctuation">(</span>applicationEvent<span class="token punctuation">,</span> eventType<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p><code>refresh()</code>的<code>initApplicationEventMulticaster()</code>将<code>applicationEventMulticaster</code>初始化为<code>SimpleApplicationEventMulticaster</code></p></blockquote><p>在实现类<code>SimpleApplicationEventMulticaster</code>的方法中，会找到已注册的<code>ApplicationListener</code>列表，然后分别调用<code>invokeListener</code>方法（将监听和事件作为参数传到方法并执行的过程就是发送广播的过程）。</p><p>底层调用的是<code>listener.onApplicationEvent(event);</code>方法，也就是各个监听实现类单独处理广播消息的逻辑。</p><h3 id="消息与监听绑定" tabindex="-1"><a class="header-anchor" href="#消息与监听绑定" aria-hidden="true">#</a> 消息与监听绑定</h3><p>看到这儿，你是不是已经发现了：消息类型和监听器的绑定发生在广播过程中。接下来就让我们去一探究竟</p><p>我们看一下<code>multicastEvent()</code>方法中的<code>getApplicationListeners(event, type)</code>方法。</p><p>在该方法中，用到了<code>ConcurrentHashMap</code>类型的缓存<code>retrieverCache</code>，所以每种类型的事件在广播的时候会触发<strong>一次</strong>绑定操作。它的<strong>key</strong>由事件的来源和类型确定，它的<strong>value</strong>中就包含了由事件来源和类型所确定的所有监听列表。</p><p>其中绑定的逻辑就出现在<code>retrieveApplicationListeners</code>方法中，大家可以去源码中查看。</p><h2 id="实战教学" tabindex="-1"><a class="header-anchor" href="#实战教学" aria-hidden="true">#</a> 实战教学</h2><p>纸上得来终觉浅，绝知此事要躬行。为了更好地理解广播与监听的流程，我们当然得用实战来加以辅佐！</p><h3 id="自定义事件" tabindex="-1"><a class="header-anchor" href="#自定义事件" aria-hidden="true">#</a> 自定义事件</h3><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyEvent</span> <span class="token keyword">extends</span> <span class="token class-name">ApplicationContextEvent</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">MyEvent</span><span class="token punctuation">(</span><span class="token class-name">ApplicationContext</span> source<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="自定义广播" tabindex="-1"><a class="header-anchor" href="#自定义广播" aria-hidden="true">#</a> 自定义广播</h3><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyPublisher</span> <span class="token keyword">implements</span> <span class="token class-name">ApplicationEventPublisherAware</span><span class="token punctuation">,</span> <span class="token class-name">ApplicationContextAware</span> <span class="token punctuation">{</span>

	<span class="token keyword">private</span> <span class="token class-name">ApplicationEventPublisher</span> applicationEventPublisher<span class="token punctuation">;</span>

	<span class="token keyword">private</span> <span class="token class-name">ApplicationContext</span> applicationContext<span class="token punctuation">;</span>

	<span class="token annotation punctuation">@Override</span>
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setApplicationEventPublisher</span><span class="token punctuation">(</span><span class="token class-name">ApplicationEventPublisher</span> applicationEventPublisher<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>applicationEventPublisher <span class="token operator">=</span> applicationEventPublisher<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token annotation punctuation">@Override</span>
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setApplicationContext</span><span class="token punctuation">(</span><span class="token class-name">ApplicationContext</span> applicationContext<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span> <span class="token punctuation">{</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>applicationContext <span class="token operator">=</span> applicationContext<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">//发送广播消息</span>
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">publishEvent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;我要开始发送消息了。。。&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token class-name">MyEvent</span> myEvent <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyEvent</span><span class="token punctuation">(</span>applicationContext<span class="token punctuation">)</span><span class="token punctuation">;</span>
		applicationEventPublisher<span class="token punctuation">.</span><span class="token function">publishEvent</span><span class="token punctuation">(</span>myEvent<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>MyPublisher</code>实现了<code>ApplicationEventPublisherAware</code>接口 ，在<code>spring</code>初始化（见上文中的<code>invokeAwareInterfaces</code>）的时候会回调<code>setApplicationEventPublisher</code>方法，获取到初始化（添加<code>bean</code>后置处理器<code>ApplicationContextAwareProcessor</code>）时的<code>AbstractApplicationContext</code>，而<code>AbstractApplicationContext</code>又间接实现了<code>ApplicationEventPublisher</code>而获得发送能力。真正执行的是 <code>AbstractApplicationContext</code> 类中的 <code>publishEvent</code> 方法。</p><h3 id="自定义监听" tabindex="-1"><a class="header-anchor" href="#自定义监听" aria-hidden="true">#</a> 自定义监听</h3><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyEventListener</span> <span class="token keyword">implements</span> <span class="token class-name">ApplicationListener</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">MyEvent</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onApplicationEvent</span><span class="token punctuation">(</span><span class="token class-name">MyEvent</span> event<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;我监听到你的消息了&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>MyEventListener</code>实现了<code>ApplicationListener</code>接口，在<code>spring</code>初始化（见上文中的<code>addApplicationListener</code>）的时候会添加到<code>applicationListeners</code>中，在执行<code>publishEvent</code> 方法时就会走<code>MyEventListener</code>中的<code>onApplicationEvent</code>方法。</p><h3 id="客户端" tabindex="-1"><a class="header-anchor" href="#客户端" aria-hidden="true">#</a> 客户端</h3><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@RestController</span>
<span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">&quot;/demo&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DemoTest</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">private</span> <span class="token class-name">MyPublisher</span> myPublisher<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">&quot;/test&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        myPublisher<span class="token punctuation">.</span><span class="token function">publishEvent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>访问<code>127.0.0.1:8008/demo/test</code>就可以发送广播了，发送与监听内容如下：</p><div class="language-xml line-numbers-mode" data-ext="xml"><pre class="language-xml"><code>我要开始发送消息了。。。
我监听到你的消息了
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>看到这儿，相信你己经完全掌握了广播与监听的精髓了，赶快实践起来吧。阿Q将持续更新<code>java</code>实战方面的文章，感兴趣的可以关注下！</p>`,49);function g(f,y){const s=i("ExternalLinkIcon");return o(),p("div",null,[d,u,n("p",null,[n("a",r,[a("之前的文章"),e(s)]),a("中我们已经介绍过如何在项目中快速上手“事件通知机制”，相信大家已经掌握了。但是我们作为高级"),k,a("，要知其然，更要知其所以然。今天就带大家从源码的角度来分析一下"),v,a("的底层实现原理。")]),n("blockquote",null,[n("p",null,[a("源码导入"),n("a",b,[a("教程"),e(s)]),a("也给你准备好了，不来试试吗？")]),m]),h])}const x=t(l,[["render",g],["__file","源码级别的广播与监听实现.html.vue"]]);export{x as default};
