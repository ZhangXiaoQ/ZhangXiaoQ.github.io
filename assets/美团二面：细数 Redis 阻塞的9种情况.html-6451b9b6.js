import{_ as n,W as d,X as t,Y as e,Z as a,a0 as s,a2 as i,C as l}from"./framework-a9f5de78.js";const o={},h=i(`<p>前两天去美团面试的陈同学回来了，看他满脸泄气的样子，准是没拿到 Offer。</p><p>听了他面试的经过，真替他感到惋惜。究其原因，是被一道面试题拦住了去路：看你简历上写着精通 Redis，请你总结一下 Redis 中存在的阻塞问题吧。</p><p>正好阿Q这几天正在研究 Redis，就顺便在这儿给大家做个总结。</p><h2 id="命令阻塞" tabindex="-1"><a class="header-anchor" href="#命令阻塞" aria-hidden="true">#</a> 命令阻塞</h2><p>使用不当的命令造成客户端阻塞：</p><ul><li>keys * ：获取所有的 key 操作；</li><li>Hgetall：返回哈希表中所有的字段和；</li><li>smembers：返回集合中的所有成员；</li></ul><p>这些命令时间复杂度是O(n)，有时候也会全表扫描，随着n的增大耗时也会越大从而导致客户端阻塞。</p><h2 id="save-阻塞" tabindex="-1"><a class="header-anchor" href="#save-阻塞" aria-hidden="true">#</a> SAVE 阻塞</h2><p>大家都知道 Redis 在进行 RDB 快照的时候，会调用系统函数 fork() ，创建一个子线程来完成临时文件的写入，而触发条件正是配置文件中的 save 配置。</p><p>当达到我们的配置时，就会触发 bgsave 命令创建快照，这种方式是不会阻塞主线程的，而手动执行 save 命令会在主线程中执行，<strong>阻塞</strong>主线程。</p><h2 id="同步持久化" tabindex="-1"><a class="header-anchor" href="#同步持久化" aria-hidden="true">#</a> 同步持久化</h2><p>当 Redis 直接记录 AOF 日志时，如果有大量的写操作，并且配置为同步持久化</p><div class="language-xml line-numbers-mode" data-ext="xml"><pre class="language-xml"><code>appendfsync always
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>即每次发生数据变更会被立即记录到磁盘，因为写磁盘比较耗时，性能较差，所以有时会阻塞主线程。</p><h2 id="aof-重写" tabindex="-1"><a class="header-anchor" href="#aof-重写" aria-hidden="true">#</a> AOF 重写</h2><ol><li><p>fork 出一条子线程来将文件重写，在执行 <code>BGREWRITEAOF</code> 命令时，Redis 服务器会维护一个 AOF 重写缓冲区，该缓冲区会在子线程创建新 AOF 文件期间，记录服务器执行的所有写命令。</p></li><li><p>当子线程完成创建新 AOF 文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新 AOF 文件的末尾，使得新的 AOF 文件保存的数据库状态与现有的数据库状态一致。</p></li><li><p>最后，服务器用新的 AOF 文件替换旧的 AOF 文件，以此来完成 AOF 文件重写操作。</p></li></ol><p>阻塞就是出现在第2步的过程中，将缓冲区中新数据写到新文件的过程中会产生<strong>阻塞</strong>。</p><h2 id="aof-日志" tabindex="-1"><a class="header-anchor" href="#aof-日志" aria-hidden="true">#</a> AOF 日志</h2><p>AOF 的日志记录不像关系型数据库那样在执行命令之前记录日志（方便故障恢复），而是采用先执行命令后记录日志的方式。</p><p>原因就是 AOF 记录日志是不会对命令进行语法检查的，这样就能减少额外的检查开销，不会对当前命令的执行产生阻塞，但可能会给下一个操作带来阻塞风险。</p><p><strong>这是因为 AOF 日志也是在主线程中执行的</strong>，如果在把日志文件写入磁盘时，磁盘写压力大，就会导致写盘很慢，进而导致后续的操作也无法执行了。</p><h2 id="大-key-问题" tabindex="-1"><a class="header-anchor" href="#大-key-问题" aria-hidden="true">#</a> 大 Key 问题</h2><p>大 key 并不是指 key 的值很大，而是 key 对应的 value 很大。</p><p>大 key 造成的阻塞问题如下：</p><ul><li>客户端超时阻塞：由于 Redis 执行命令是单线程处理，然后在操作大 key 时会比较耗时，那么就会阻塞 Redis，从客户端这一视角看，就是很久很久都没有响应。</li><li>引发网络阻塞：每次获取大 key 产生的网络流量较大，如果一个 key 的大小是 1 MB，每秒访问量为 1000，那么每秒会产生 1000MB 的流量，这对于普通千兆网卡的服务器来说是灾难性的。</li><li>阻塞工作线程：如果使用 del 删除大 key 时，会阻塞工作线程，这样就没办法处理后续的命令。</li></ul><h3 id="查找大-key" tabindex="-1"><a class="header-anchor" href="#查找大-key" aria-hidden="true">#</a> 查找大 key</h3><p>当我们在使用 Redis 自带的 <code>--bigkeys</code> 参数查找大 key 时，最好选择在从节点上执行该命令，因为主节点上执行时，会<strong>阻塞</strong>主节点。</p>`,27),p=e("li",null,[e("p",null,"我们还可以使用 SCAN 命令来查找大 key；")],-1),c=e("p",null,"通过分析 RDB 文件来找出 big key，这种方案的前提是 Redis 采用的是 RDB 持久化。网上有现成的工具：",-1),_={href:"https://github.com/sripathikrishnan/redis-rdb-tools",target:"_blank",rel:"noopener noreferrer"},u={href:"https://github.com/weiyanwei412/rdb_bigkeys",target:"_blank",rel:"noopener noreferrer"},g=i('<h2 id="删除大-key" tabindex="-1"><a class="header-anchor" href="#删除大-key" aria-hidden="true">#</a> 删除大 key</h2><p>删除操作的本质是要释放键值对占用的内存空间。</p><p>释放内存只是第一步，为了更加高效地管理内存空间，在应用程序释放内存时，<strong>操作系统需要把释放掉的内存块插入一个空闲内存块的链表</strong>，以便后续进行管理和再分配。这个过程本身需要一定时间，而且会<strong>阻塞</strong>当前释放内存的应用程序。</p><p>所以，如果一下子释放了大量内存，空闲内存块链表操作时间就会增加，相应地就会造成 Redis <strong>主线程的阻塞</strong>，如果主线程发生了阻塞，其他所有请求可能都会超时，超时越来越多，会造成 Redis 连接耗尽，产生各种异常。</p><blockquote><p>删除大 key 时建议采用分批次删除和异步删除的方式进行。</p></blockquote><h2 id="清空数据库" tabindex="-1"><a class="header-anchor" href="#清空数据库" aria-hidden="true">#</a> 清空数据库</h2><p>清空数据库和上面 bigkey 删除也是同样道理，flushdb、flushall 也涉及到删除和释放所有的键值对，也是 Redis 的阻塞点。</p><h2 id="集群扩容" tabindex="-1"><a class="header-anchor" href="#集群扩容" aria-hidden="true">#</a> 集群扩容</h2><p>Redis 集群可以进行节点的动态扩容缩容，这一过程目前还处于<strong>半自动</strong>状态，需要人工介入。</p><p>在扩缩容的时候，需要进行数据迁移。而 Redis 为了保证迁移的一致性，迁移所有操作都是<strong>同步</strong>操作。</p><p>执行迁移时，两端的 Redis 均会进入时长不等的<strong>阻塞</strong>状态，对于小Key，该时间可以忽略不计，但如果一旦 Key 的内存使用过大，严重的时候会接触发集群内的故障转移，造成不必要的切换。</p><p>参考文章：</p>',12),k={href:"https://mp.weixin.qq.com/s/Q4Etl5xJZtOhXgy8UK_69g",target:"_blank",rel:"noopener noreferrer"};function y(f,b){const r=l("ExternalLinkIcon");return d(),t("div",null,[h,e("ul",null,[p,e("li",null,[c,e("ul",null,[e("li",null,[e("p",null,[e("a",_,[a("redis-rdb-tools"),s(r)]),a("：Python 语言写的用来分析 Redis 的 RDB 快照文件用的工具")])]),e("li",null,[e("p",null,[e("a",u,[a("rdb_bigkeys"),s(r)]),a("：Go 语言写的用来分析 Redis 的 RDB 快照文件用的工具，性能更好。")])])])])]),g,e("p",null,[e("a",k,[a("https://mp.weixin.qq.com/s/Q4Etl5xJZtOhXgy8UK_69g"),s(r)])])])}const x=n(o,[["render",y],["__file","美团二面：细数 Redis 阻塞的9种情况.html.vue"]]);export{x as default};
