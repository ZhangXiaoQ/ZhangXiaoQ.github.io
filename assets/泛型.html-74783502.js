import{_ as n,W as s,X as a,a2 as e}from"./framework-a9f5de78.js";const t={},o=e(`<p>事情是这个样子的......</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3b5bab17412245cfafb4d3d5223ca4b6~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>对话中的截图如下：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb28db5ecda44be6999cd38a0d0a67f4~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>看了阿Q的解释，你是否也和“马小跳”一样存在疑问呢？请往👇看</p><p>我们都知道在<code>java</code>中，只要是类型兼容，就可以将一种类型的对象分配给另一种类型的对象。比如可以将一个<code>Integer</code>类型的对象分配给<code>Object</code>类型的对象，因为<code>Object</code> 是<code>Integer</code>的超类。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Object</span> someObject <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Integer</span> someInteger <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
someObject <span class="token operator">=</span> someInteger<span class="token punctuation">;</span> <span class="token comment">//OK</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在面向对象中，我们把它称之为 <strong>is a</strong> 的关系。因为<code>Integer</code>是<code>Object</code>的一种子类，所以允许被赋值。</p><p>又因为<code>Integer</code>也是<code>Number</code>的一种子类，所以下边的代码也是有效的：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">someMethod</span><span class="token punctuation">(</span><span class="token class-name">Number</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>

<span class="token function">someMethod</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// OK</span>
<span class="token function">someMethod</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Double</span><span class="token punctuation">(</span><span class="token number">10.1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// OK</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当然泛型也是如此，在执行泛型类型调用时，将<code>Number</code>作为其类型参数传递，如果参数是<code>Number</code>的子类型，则允许任何后续的<code>add</code>调用:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Box</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Number</span><span class="token punctuation">&gt;</span></span> box <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Box</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Number</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
box<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// OK</span>
box<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Double</span><span class="token punctuation">(</span><span class="token number">10.1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// OK</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在我们来看以下代码：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">boxTest</span><span class="token punctuation">(</span><span class="token class-name">Box</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Number</span><span class="token punctuation">&gt;</span></span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>该方法接收什么类型的参数呢？</p><p>通过该方法，大家肯定知道它的参数类型为<code>Box&lt;Number&gt;</code>，但是大家思考一个问题：你认为<code>Box&lt;Integer&gt;</code> 和<code>Box&lt;Double&gt;</code>类型的参数可以传入吗？</p><p>答案是<strong>否定</strong>的。</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f880f9c9d60a4738b29db61689372d83~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>尽管<code>Integer</code>是<code>Number</code>的子类型，但<code>Box&lt;Integer&gt;</code> 和<code>Box&lt;Double&gt;</code>不是<code>Box&lt;Number&gt;</code>的子类，它俩的父类对象是<code>Object</code>。<strong>文首的对话表达的就是这个意思。</strong></p><p>那么问题来了，当类的泛型相关时，如何在两个泛型类之间创建类似子类型的关系呢？例如如何让<code>Box&lt;Integer&gt;</code> 和<code>Box&lt;Double&gt;</code>变得与<code>Box&lt;Number&gt;</code>有关呢？</p><p>为了搞懂这个问题，我们先来了解一下同一类型的对象是如何实现子类型化的吧。</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f3e059d672f492fb106a496366bf155~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>通过分析源码我们可以发现：<code>ArrayList&lt;E&gt;</code> 实现了 <code>List&lt;E&gt;</code>，<code>List&lt;E&gt;</code> 继承了<code>Collection&lt;E&gt;</code>，所以<code>ArrayList&lt;String&gt;</code>是<code>List&lt;String&gt;</code>的子类型， <code>List&lt;String&gt;</code>是 <code>Collection&lt;String&gt;</code>的子类型。因此当我们在传递参数时，<code>ArrayList&lt;String&gt;</code>类型的是可以给<code>List&lt;E&gt;</code>或者<code>Collection&lt;E&gt;</code>传递的。</p><blockquote><p>只要不改变类型参数，类型之间的子类型关系就会保留。</p></blockquote><p>如果我们想要定义我们自己的列表接口<code>PayloadList</code>，使得泛型类型P的可选值与每个元素相关联，可以定义如下：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">interface</span> <span class="token class-name">PayloadList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">,</span><span class="token class-name">P</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
  <span class="token keyword">void</span> <span class="token function">setPayload</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token class-name">P</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1bad5d8a4ac4ed996c0daa2468aed14~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>则<code>PayloadList&lt;String,String&gt;</code>、<code>PayloadList&lt;String,Integer&gt;</code>、<code>PayloadList&lt;String,Exception&gt;</code>都是<code>List&lt;String&gt;</code>的子类型。</p><blockquote><p>小结：可以通过继承泛型类或者实现接口来对其进行子类型化。</p></blockquote><p>搞懂了子类型化的问题，我们回到“如何在两个泛型类之间创建类似子类型的关系“的问题。</p><p>泛型类或者接口并不会仅仅因为它们的类型之间有关系而变得相关，如果要达到相关，我们可以使用<strong>通配符</strong>来创建泛型类或接口之间的关系。</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b67e4400b5ba469d94319362c6c164bf~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><code>Box&lt;Integer&gt;</code> 和<code>Box&lt;Number&gt;</code>的父类对象其实是<code>Box&lt;?&gt;</code></p><p>为了在这些类之间创建关系，以便代码可以通过<code>Box&lt;Integer&gt;</code>访问<code>Box&lt;Number&gt;</code>的方法，可以使用上限通配符:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Box</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> initBox <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Box</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Box</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Number</span><span class="token punctuation">&gt;</span></span> numberBox <span class="token operator">=</span> initBox<span class="token punctuation">;</span>
<span class="token comment">// OK. Box&lt;? extends Integer&gt; is a subtype of Box&lt;? extends Number&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因为<code>Integer</code>是<code>Number</code>的子类型，<code>numberBox</code>的泛型是<code>Number</code>对象子类，所以在<code>intBox</code>和<code>numberBox</code>之间存在关系。</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b15f428724d54069a75a185097e094d7~tplv-k3u1fbpfcp-zoom-1.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>图为用<strong>上限</strong>和<strong>下限</strong>通配符声明的几个类之间的关系。</p>`,38),c=[o];function p(l,i){return s(),a("div",null,c)}const u=n(t,[["render",p],["__file","泛型.html.vue"]]);export{u as default};
